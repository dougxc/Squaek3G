/*
 * Copyright 2004 Sun Microsystems, Inc. All Rights Reserved.
 *
 * This software is the proprietary information of Sun Microsystems, Inc.
 * Use is subject to license terms.
 *
 * This is a part of the Squawk JVM.
 */
package com.sun.squawk;

import java.io.*;
import java.util.*;
import java.util.Arrays;
import java.util.jar.*;
import java.util.zip.*;
import javax.microedition.io.*;

import com.sun.squawk.util.*;
//import com.sun.squawk.util.Vector;
import com.sun.squawk.translator.*;
import com.sun.squawk.translator.ir.InstructionEmitter;
import com.sun.squawk.SuiteCreator.*;
import com.sun.squawk.io.connections.ClasspathConnection;

/**
 * The romizer statically executes the translator over a set of classes
 * that are to be romized and then transfers the romized classes
 * from the host JVM's memory to an image file.
 */
public class Romizer {

    /**
     * The "build.properties" file.
     */
    static Properties buildProperties = new Properties();

    /**
     * Reads the contents of the build properties.
     */
    static {
        FileInputStream inputStream = null;
        try {
            inputStream = new FileInputStream("build.properties");
            buildProperties.load(inputStream);
        } catch(IOException ex) {
            throw new Error("Could not find build.properties");
        } finally {
            if (inputStream != null) {
                try {inputStream.close();} catch (IOException e) {}
                inputStream = null;
            }
        }
        try {
            inputStream = new FileInputStream("build.override");
            buildProperties.load(inputStream);
        } catch(IOException ex) {
        } finally {
            if (inputStream != null) {
                try {inputStream.close();} catch (IOException e) {}
                inputStream = null;
            }
        }
    }

    /**
     * Endianess flag.  Default is host endianess
     */
    static boolean bigEndian;

    /**
     * The name of the suite being romized.
     */
    private String suiteName;

    /**
     * The suite being romized.
     */
    private Suite suite;

    /**
     * The search path for classes in the suite.
     */
    private String classPath;

    /**
     * The Romizer instance used to create the parent of the suite being romized.
     */
    private Romizer parent;

    /**
     * The files generated by the romizer.
     */
    private Vector generatedFiles = new Vector();

    /**
     * Type of suite to create. This controls how much of the symbolic information is retained
     * in the suite when it is closed.
     */
    private int suiteType;

    /**
     * The class name patterns to be excluded as defined in an excludes files.
     */
    private Vector excludes;

    /**
     * Specifies if the _classes.jar and _rt.jar files should be created.
     */
    private boolean createJars;

    /**
     * Specifies if the timing information should be displayed.
     */
    private static boolean timer;

/*if[J2ME.STATS]*/
    /**
     * Specifies if translation statistics should be gathered and printed.
     */
    private static boolean stats = false;
/*end[J2ME.STATS]*/

    /**
     * Creates the romizer instance used to romize a suite.
     *
     * @param parent  the romizer that was used to romize the parent suite
     *                or null if this is the romizer creating the bootstrap suite
     */
    private Romizer(Romizer parent) {
        if (parent != null) {
            suiteType = parent.suiteType;
            this.parent = parent;
        } else {
            suiteType = Suite.LIBRARY;
        }
    }


    /**
     * Prints the usage message.
     *
     * @param  errMsg  an optional error message
     */
    private void usage(String errMsg) {
        PrintStream out = System.out;
        if (errMsg != null) {
            out.println("**** " + errMsg + " ****");
        }
        out.println("Usage: romize [-options] classnames|dirnames|jarfiles...");
        out.println("where options include:");
        out.println();
        out.println("    -cp:<directories and jar/zip files separated by '"+File.pathSeparatorChar+"'>");
        out.println("                        paths where classes and sources can be found (required)");
        out.println("    -o:<name>           name of suite to generate (required)");
        out.println("    -jars               create <suite_name>_classes.jar which contains the class files");
        out.println("                        from which the suite was built");
        out.println("    -exclude:<file>     excludes classes that match the class names or packages");
        out.println("                        in file ('<name>.exclude' is used implicitly)");
        out.println("    -endian:<value>     endianess ('big' or 'little') for generated suite (required)");
        out.println("    -arch:<name>        base name for dynamic compiler. Full name will be");
        out.println("                        \"com.sun.squawk.compiler.<name>Compiler\"");
        out.println("    -strip:<t>          strip symbolic information according to <t>:");
        out.println("                           'd' - debug: retain all symbolic info");
        out.println("                           'a' - application: discard all symbolic info");
        out.println("                           'l' - library (default): discard symbolic info");
        out.println("                                 for private/package-private fields and methods");
        out.println("                           'e' - extendable library: discard symbolic info");
        out.println("                                 for private fields and methods");
        out.println("    -lnt                retain line number tables");
        out.println("    -lvt                retain local variable tables");
        out.println("    -timer              print various phase timing statistics");
/*if[J2ME.STATS]*/
        out.println("    -stats              print various translation statistics");
/*end[J2ME.STATS]*/
        out.println("    -traceimage         trace building of ROM image");
        if (Klass.TRACING_ENABLED) {
        out.println("    -traceloading       trace class loading");
        out.println("    -traceconverting    trace method conversion (includes -traceloading)");
        out.println("    -tracejvmverifier   trace verification of JVM/CLDC bytecodes");
        out.println("    -traceemitter       trace Squawk bytecode emitter");
        out.println("    -tracesquawkverifier trace verification of Squawk bytecodes");
        out.println("    -traceclassinfo     trace loading of class meta-info (i.e. implemented");
        out.println("                        interfaces, field meta-info & method meta-info)");
        out.println("    -traceclassfile     trace low-level class file elements");
        out.println("    -traceir0           trace the IR built from the JVM bytecodes");
        out.println("    -traceir1           trace optimized IR with JVM bytcode offsets");
        out.println("    -traceir2           trace optimized IR with Squawk bytcode offsets");
        out.println("    -tracemethods       trace emitted Squawk bytecode methods");
        out.println("    -tracepruning       trace pruning of symbolic information");
        out.println("    -traceoms           trace object memory serialization");
        out.println("    -traceswapper       trace endianess swapping");
        out.println("    -tracefilter:<string>  filter trace with simple string filter");
        }
        out.println("    -help               show this help message and exit");
        out.println();
        out.println();
        out.println("More than one suite can be created by separating the arguments for each");
        out.println("suite with '--'. For example:");
        out.println();
        out.println("  romize -o:squawk -cp:j2me/j2meclasses j2me/j2meclasses -- -cp:translator/j2meclasses -o:translator translator/j2meclasses");
        out.println();
    }

    /**
     * Processes a file with specifications of classes to exclude from the romizing process.
     * Each line in the file may be guarded with a property whose value is determined from
     * 'build.properties'.
     *
     * @param file     the file of exclude specifications
     * @return the read in specifications
     */
    private Vector readExcludesFile(String file) {
        Vector lines = new Vector();
        ArgsUtilities.readLines(file, lines);

        Vector excludes = new Vector(lines.size());
        for (Enumeration e = lines.elements(); e.hasMoreElements(); ) {
            String line = ((String)e.nextElement()).trim();
            if (line.length() == 0 || line.startsWith("#")) {
                continue;
            }
            int index = line.indexOf(' ');
            if (index != -1) {
                // This is an exclusion predicated on a build property
                String predicate = line.substring(0, index);
                line = line.substring(index+1);
                String value = "false"; // The default value where there is not '='.
                index = predicate.indexOf('=');
                if (index != -1) {
                    value = predicate.substring(index+1);
                    predicate = predicate.substring(0, index);
                }
                if (!buildProperties.getProperty(predicate, "false").equals(value)) {
                    continue;
                }
                while (line.charAt(0) == ' ') { // remove any extra spaces
                    line = line.substring(1);
                }
            }
            excludes.addElement(line);
        }
        return excludes;
    }

    /**
     * Commmand line interface.
     *
     * @param args
     */
    public static void main(String args[]) throws IOException {
        Romizer romizer = null;
        while (args != null) {
            romizer = new Romizer(romizer);
            args = romizer.run(args);
        }
    }

    /**
     * Runs this instance of the romizer to produce a single suite.
     *
     * @param args  the arguments specifying the options and components of the suite
     * @return the remaining command line arguments after a "--" argument specifying subsequent suites or null
     *         if there are none
     */
    private String[] run(String[] args) {

        if (args.length == 0) {
            usage(null);
            return null;
        }
        try {
            args = ArgsUtilities.expandArgFiles(args);
            final Vector classNames = new Vector();
            final Vector resources = new Vector();
            args = processSuiteArgs(args, classNames, resources);
            if (args == null && suite == null) {
                return null;
            }

            // Load and translate the classes in the suite
            ComputationTimer.time("translating", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    translate(classNames);
                    return null;
                }
            });
            // Install resources found
            for (int i=0, maxI=resources.size(); i < maxI; i++) {
                ResourceFile resourceFile = (ResourceFile) resources.elementAt(i);
                SuiteCreator.Loader.installResourceFile(suite, resourceFile);
            }
            
            // Create the image file for the suite
            ComputationTimer.time("suite file creation", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    createImage();
                    return null;
                }
            });

            if (suite.getParent() == null) {
                // Create the header file for the C implementation of the Squawk interpreter
                ComputationTimer.time("rom header creation", new ComputationTimer.ComputationException() {
                    public Object run() throws Exception {
                        createCHeader();
                        return null;
                    }
                });
            }

            ComputationTimer.time(suiteName + ".api creation", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    createSuiteAPI();
                    return null;
                }
            });
            if (timer) {
                ComputationTimer.dump(System.out);
                ComputationTimer.reset();
            }

        } catch (Exception e) {
            throw new RuntimeException(e);
        }

/*if[J2ME.STATS]*/
        if (stats) {
            if (Klass.TRACING_ENABLED) {
                KlassMetadata.Debug.printStats(System.out);
            }
            com.sun.squawk.translator.ir.InstructionEmitter.printStats();
        }
/*end[J2ME.STATS]*/

        System.out.println("Romizer processed " + suite.getClassCount() + " classes and generated these files:");
        for (Enumeration e = generatedFiles.elements(); e.hasMoreElements();) {
            System.out.println("  " + e.nextElement());
        }

        return args;
    }

    /**
     * Parses and processes a given set of command line arguments to translate a single suite.
     *
     * @param   args        the command line arguments
     * @param   classNames  a vector to collect the names of the classes to be translated
     * @param   Vector<ResourceFile> resources  a vector to collect the resources to be included
     * @return  the remaining command line arguments specifying a subsequent suite or null
     * @throws RuntimeException if the arguments are malformed
     */
    private String[] processSuiteArgs(String[] args, Vector classNames, Vector resources) {
        int argc = 0;
        String excludeFile = null;

        while (argc != args.length) {
            String arg = args[argc];

            if (arg == null || arg.charAt(0) != '-') {
                break;
            } else if (arg.startsWith("-cp:")) {
                classPath = ArgsUtilities.toPlatformPath(arg.substring("-cp:".length()), true);
            } else if (arg.startsWith("-exclude:")) {
                excludeFile = arg.substring("-exclude:".length());
            } else if (arg.startsWith("-o:")) {
                suiteName = arg.substring("-o:".length());
            } else if (arg.equals("-jars")) {
                createJars = true;
            } else if (arg.startsWith("-endian:")) {
                String value = arg.substring("-endian:".length());
                if (value.equals("big")) {
                    bigEndian = true;
                } else if (value.equals("little")) {
                    bigEndian = false;
                } else {
                    usage("invalid endianess: " + value);
                    throw new RuntimeException();
                }
            } else if (arg.startsWith("-arch:")) {
                String arch = arg.substring("-arch:".length()).toUpperCase();
                buildProperties.put("ARCHITECTURE", arch);
            } else if (arg.startsWith("-strip:") || arg.startsWith("-prune:")) {
                char type = arg.substring("-strip:".length()).charAt(0);
                if (type == 'a') {
                    suiteType = Suite.APPLICATION;
                } else if (type == 'd') {
                    suiteType = Suite.DEBUG;
                } else if (type == 'l') {
                    suiteType = Suite.LIBRARY;
                } else if (type == 'e') {
                    suiteType = Suite.EXTENDABLE_LIBRARY;
                } else {
                    usage("invalid suite type: " + type);
                    throw new RuntimeException();
                }
            } else if (arg.equals("-lnt")) {
                MethodMetadata.preserveLineNumberTables();
            } else if (arg.equals("-lvt")) {
                MethodMetadata.preserveLocalVariableTables();
            } else if (arg.equals("-timer")) {
                timer = true;
/*if[J2ME.STATS]*/
            } else if (arg.equals("-stats")) {
                stats = true;
/*end[J2ME.STATS]*/
            } else if (arg.startsWith("-trace")) {
                if (arg.startsWith("-tracefilter:")) {
                    String optArg = arg.substring("-tracefilter:".length());
                    Tracer.setFilter(optArg);
                } else {
                    Tracer.enableFeature(arg.substring("-trace".length()));
                    if (arg.equals("-traceconverting")) {
                        Tracer.enableFeature("loading"); // -traceconverting subsumes -traceloading
                    }
                }
            } else if (arg.startsWith("-h")) {
                usage(null);
                return null;
            } else {
                usage("Unknown option "+arg);
                throw new RuntimeException();
            }
            argc++;
        }

        if (suiteName == null) {
            usage("missing -o option");
            throw new RuntimeException();
        }

        if (classPath == null) {
            usage("missing -cp option");
            throw new RuntimeException();
        }

        if (suiteType == Suite.LIBRARY || suiteType == Suite.EXTENDABLE_LIBRARY) {
            File file = new File(suiteName + "." + (suiteType == Suite.LIBRARY ? "library" : "extendable.library") + ".properties");
            if (file.exists()) {
                VM.resetSymbolsStripping(file);
            }
        }

        // Parse class name args (if any)
        while (argc != args.length) {
            String classArg = args[argc++];
            if (classArg.equals("--")) {
                break;
            }
            ArgsUtilities.processClassArg(ArgsUtilities.toPlatformPath(classArg, false), classNames, resources);
        }

        if (!classNames.isEmpty()) {
            if (excludeFile == null && new File(suiteName + ".exclude").exists()) {
                excludeFile = suiteName + ".exclude";
            }
            if (excludeFile != null) {
                excludeClasses(classNames, excludeFile);
            }

            suite = new Suite(suiteName, parent == null ? null : parent.suite);

        } else {
            usage("missing class names for suite " + suiteName);
            throw new RuntimeException();
        }

        // Return the remaining args that specify a subsequent suite (if any)
        if (argc != args.length) {
            String[] newArgs = new String[args.length - argc];
            System.arraycopy(args, argc, newArgs, 0, newArgs.length);
            return newArgs;
        } else {
            return null;
        }
    }

    /**
     * Strips classes from a list of class names based on an excludes file.
     *
     * @param classNames   the list of class names to modifiy
     * @param excludeFile  the name of the excludes file to use
     */
    private void excludeClasses(Vector classNames, String excludeFile) {

        // The exclusions are remembered in a field so that the generated
        // suite can be verified not to include any classes that should have been excluded
        excludes = readExcludesFile(excludeFile);

        Vector filteredClassNames = new Vector(classNames.size());
        boolean firstLoop = true;
        for (Enumeration e = classNames.elements(); e.hasMoreElements(); ) {
            String className = (String)e.nextElement();

            boolean include = true;
            for (Enumeration specs = excludes.elements(); specs.hasMoreElements(); ) {
                String spec = (String)specs.nextElement();
                if (firstLoop) {
                    System.out.println("excluding: " + spec);
                }
                boolean isPrefix = spec.endsWith("*");
                if (isPrefix) {
                    spec = spec.substring(0, spec.length() - 1);
                }
                if (isPrefix ? className.startsWith(spec) : className.equals(spec)) {
                    include = false;
                    break;
                }
            }
            if (include) {
                filteredClassNames.addElement(className);
            }
            firstLoop = false;
        }

        classNames.removeAllElements();
        for (Enumeration e = filteredClassNames.elements(); e.hasMoreElements();) {
            classNames.addElement(e.nextElement());
        }
    }

    /**
     * Loads and translates the classes in the suite.
     *
     * @param  classNames the names of the classes that are to be translated
     */
    private void translate(Vector classNames) {
        if (classNames.isEmpty()) {
            throw new RuntimeException("No classes found for "+suite);
        }

        System.out.println("[translating "+suite+" ...]");

        VM.setCurrentIsolate(null);
        Isolate isolate = new Isolate(null, null, suite);
        VM.setCurrentIsolate(isolate);

        isolate.setTranslator(new Translator());
        TranslatorInterface translator = isolate.getTranslator();
        translator.open(suite, classPath);

        // Sort the classes in order to make sure that regardless of what platform we are on
        // the order of the classes will be the same
        String[] sortedClassNames = new String[classNames.size()];
        classNames.copyInto(sortedClassNames);
        Arrays.sort(sortedClassNames, new Comparator() {
            public int compare(Object object1, Object object2) {
                if (object1 == object2) {
                    return 0;
                }
                return ((String) object1).compareTo(((String) object2));
            }
        });
        // Create classes for each class name
        for (int i=0, maxI=sortedClassNames.length; i < maxI; i++) {
            Klass.getClass(sortedClassNames[i], false);
        }

        // Compute the complete class closure.
        translator.close();

        // Ensure no classes that were meant to be excluded have been included
        verifyExclusions(suite);

    }

    /**
     * Ensures that no classes that were meant to be excluded have been included in a given suite.
     * If an exclusion was violated, then a warning is sent to the console.
     *
     * @param suite  the suite to verify
     */
    private void verifyExclusions(Suite suite) {
        if (excludes != null) {
            for (int i = 0; i != suite.getClassCount(); ++i) {
                Klass klass = suite.getKlass(i);
                if (klass == null) {
                    continue;
                }

                String className = (String)klass.getInternalName();
                for (Enumeration specs = excludes.elements(); specs.hasMoreElements(); ) {
                    final String spec = (String)specs.nextElement();
                    if (spec.endsWith("*") ? className.startsWith(spec.substring(0, spec.length() - 1)) : className.equals(spec)) {
                        System.err.println("**WARNING**: suite includes class '" + className + "' that is matched by exclusion spec '" + spec + "'");
                    }
                }
            }
        }
    }

    /*---------------------------------------------------------------------------*\
     *                             Image building                                *
    \*---------------------------------------------------------------------------*/

    /**
     * Creates the serialized object memory representing the classes in the translated suite.
     */
    private void createImage() throws IOException {

        // Open the map file.
        File file = new File(suiteName + ".sym");
        PrintStream symbols = VM.Streams[VM.STREAM_SYMBOLS] = new PrintStream(new FileOutputStream(file));
        generatedFiles.addElement(file.getAbsolutePath());

        GC.setAllocationEnabled(true);

        // Strip the symbols in the suite and close it.
        Suite suite = this.suite.strip(suiteType);
        suite.close();

        String url = "file://" + suite.getName() + ".suite";
        DataOutputStream dos = Connector.openDataOutputStream(url);

        // Save the (canonical) address at which the suite will be saved
        int memoryStart = NativeUnsafe.getMemorySize();

        // The boostrap suite has a special URI
        String uri = suite.getParent() == null ? "memory:boostrap" : url;
        suite.save(dos, uri, bigEndian);
        generatedFiles.addElement(new File(suite.getName() + ".suite").getAbsolutePath());

        // Create the <suiteName>_classes.jar file of all the class files from which the suite was created
        if (createJars) {
            String jarFilePath = suiteName + "_classes.jar";
            File jarFile = new File(jarFilePath);
            jarClasses(jarFile, suite);
            generatedFiles.addElement(jarFile.getAbsolutePath());
        }

        // Ensures that saving worked
        NativeUnsafe.setMemorySize(memoryStart);
        ObjectMemory memory = ObjectMemoryLoader.load(Connector.openDataInputStream(url), url, false).objectMemory;

        // Add a few symbols.
        VM.printNatives(symbols);
        symbols.println("PMR.ROM_SIZE=" + memory.getSize());
        symbols.println("PMR.ROM_SUITE_TABLE=" + memory.getRoot());
        symbols.println("PMR.REVERSE_PARAMETERS=" + (Translator.REVERSE_PARAMETERS ? 1 : 0));

        Hashtable globalInts = InstructionEmitter.getGlobalIntVariables();
        symbols.println("ROM.GLOBAL.INT.COUNT="+globalInts.size());
        for (Enumeration e = globalInts.keys() ; e.hasMoreElements() ;) {
            String field = (String)e.nextElement();
            int offset = ((Integer)globalInts.get(field)).intValue();
            symbols.println("ROM.GLOBAL.INT."+offset+"="+field);
        }

        Hashtable globalAddrs = InstructionEmitter.getGlobalAddrVariables();
        symbols.println("ROM.GLOBAL.ADDR.COUNT="+globalAddrs.size());
        for (Enumeration e = globalAddrs.keys() ; e.hasMoreElements() ;) {
            String field = (String)e.nextElement();
            int offset = ((Integer)globalAddrs.get(field)).intValue();
            symbols.println("ROM.GLOBAL.ADDR."+offset+"="+field);
        }

        Hashtable globalOops = InstructionEmitter.getGlobalOopVariables();
        symbols.println("ROM.GLOBAL.OOP.COUNT="+globalOops.size());
        for (Enumeration e = globalOops.keys() ; e.hasMoreElements() ;) {
            String field = (String)e.nextElement();
            int offset = ((Integer)globalOops.get(field)).intValue();
            symbols.println("ROM.GLOBAL.OOP."+offset+"="+field);
        }

        symbols.close();
    }

    /**
     * Creates a jar file of all the class files from which a given suite was built.
     *
     * @param file   the jar file to create
     * @param suite  the suite to jar
     */
    private void jarClasses(File file, Suite suite) {
        try {
            FileOutputStream fos = new FileOutputStream(file);
            ZipOutputStream zos = new JarOutputStream(fos);
            ClasspathConnection classPath = (ClasspathConnection)Connector.open("classpath://" + this.classPath);
            for (int i = 0; i < suite.getClassCount(); i++) {
                Klass klass = suite.getKlass(i);
                if (klass.isSynthetic()) {
                    continue;
                }

                String classFilePath = klass.getName().replace('.', '/') + ".class";
                addFileToJar(zos, classPath, classFilePath);
            }
            zos.close();
        } catch (IOException e) {
            throw new RuntimeException("IO error creating jar file", e);
        }
    }

    /**
     * Adds a given file to a given jar file stream.
     *
     * @param zos        the jar stream
     * @param classPath  where to find the file
     * @param filePath   the path to the file
     * @throws IOException if there is an IO error
     */
    private void addFileToJar(ZipOutputStream zos, ClasspathConnection classPath, String filePath) throws IOException {
        byte[] data = classPath.getBytes(filePath);

        ZipEntry e = new ZipEntry(filePath);
        e.setTime(System.currentTimeMillis());
        zos.putNextEntry(e);
        zos.write(data);
        zos.closeEntry();
    }


    /*---------------------------------------------------------------------------*\
     *                           C header file generation                        *
    \*---------------------------------------------------------------------------*/

    /**
     * Creates the C header file required by the C implementation of the Squawk interpreter.
     *
     * @throws IOException if an IO error occurs
     */
    private void createCHeader() throws IOException {
        File headerFile = new File("slowvm/src/vm/rom.h");
        Properties symbols = new Properties();
        symbols.load(new FileInputStream(suiteName + ".sym"));

        if (CHeaderFileCreator.update(suite, headerFile, symbols)) {
            generatedFiles.addElement(headerFile.getAbsolutePath());
        } else {
            System.out.println(headerFile.getAbsolutePath() + " is already up to date");
        }
    }

    /*---------------------------------------------------------------------------*\
     *                           Create squawk_rt.jar                            *
    \*---------------------------------------------------------------------------*/

    /**
     * Generates a text file describing the components in the
     * suite that can be dynamically bound to.
     */
    private void createSuiteAPI() throws IOException {
        Suite suite = this.suite.strip(suiteType);
        File api = new File(suiteName + ".suite.api");
        PrintStream out = new PrintStream(new FileOutputStream(api));
        suite.printAPI(out);
        generatedFiles.addElement(api.getAbsolutePath());
        out.close();
    }

}
